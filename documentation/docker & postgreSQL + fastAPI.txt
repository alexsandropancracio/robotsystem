RELATÃ“RIO TÃ‰CNICO â€“ BASE DO BACKEND
1ï¸âƒ£ ContainerizaÃ§Ã£o com Docker (Base do Ambiente)
ğŸ“Œ O que foi feito

Criamos um Dockerfile especÃ­fico para a API (backend/Dockerfile)

Definimos:

Imagem base: python:3.12-slim

DiretÃ³rio de trabalho: /app

VariÃ¡veis de ambiente importantes:

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
ENV PYTHONPATH=/app


Instalamos dependÃªncias de sistema necessÃ¡rias para o Postgres (gcc, libpq-dev)

Instalamos dependÃªncias Python via requirements.txt

Copiamos todo o projeto para dentro do container

Subimos a aplicaÃ§Ã£o com uvicorn

ğŸ¯ Objetivo

Garantir que:

O backend rode igual em qualquer mÃ¡quina

NÃ£o haja dependÃªncia do ambiente local

O projeto esteja pronto para produÃ§Ã£o futuramente

2ï¸âƒ£ OrquestraÃ§Ã£o com Docker Compose
ğŸ“Œ O que foi feito

Criamos um docker-compose.yml com dois serviÃ§os principais:

ğŸ”¹ ServiÃ§o postgres
postgres:
  image: postgres:16
  container_name: robotsystem-postgres
  env_file:
    - .env
  volumes:
    - postgres_data:/var/lib/postgresql/data

âœ” Resultado

Banco de dados PostgreSQL isolado

ConfiguraÃ§Ã£o via .env

PersistÃªncia de dados garantida

ğŸ”¹ ServiÃ§o api
api:
  build:
    context: .
    dockerfile: backend/Dockerfile
  container_name: robotsystem-api
  env_file:
    - .env
    - backend/.env

âœ” Resultado

API rodando dentro de container

ComunicaÃ§Ã£o direta com o Postgres

Hot reload (--reload) ativo para desenvolvimento

3ï¸âƒ£ Volume Persistente do Banco de Dados
ğŸ“Œ O que foi feito

Criamos o volume:

volumes:
  postgres_data:


Montado em:

/var/lib/postgresql/data

ğŸ¯ Impacto

Mesmo que:

O container do Postgres seja removido

O docker-compose down seja executado

ğŸ‘‰ Os dados do banco NÃƒO sÃ£o apagados

âš ï¸ SÃ³ sÃ£o removidos se:

docker volume rm postgres_data

4ï¸âƒ£ Estrutura de Imports Absolutos (PadrÃ£o Profissional)
ğŸ“Œ O que foi feito

Definimos PYTHONPATH=/app

Passamos a usar imports absolutos, por exemplo:

from backend.api.db.session import engine
from backend.api.core.config import get_settings

ğŸ¯ Por que isso Ã© importante

Evita bugs em produÃ§Ã£o

Facilita testes

Evita problemas com paths relativos

Escala melhor conforme o projeto cresce

âœ” PadrÃ£o usado em empresas grandes

5ï¸âƒ£ ConfiguraÃ§Ã£o Centralizada (Settings)
ğŸ“Œ Arquivo
backend/api/core/config.py

ğŸ“Œ O que foi feito

Criamos uma classe Settings usando BaseSettings

Centralizamos:

Ambiente

API

SeguranÃ§a

Banco de dados

Lemos variÃ¡veis automaticamente do .env

@lru_cache
def get_settings() -> Settings:
    return Settings()

settings = get_settings()

ğŸ¯ Impacto

Um Ãºnico ponto de verdade

FÃ¡cil trocar ambiente (dev, staging, prod)

CÃ³digo mais limpo e seguro

6ï¸âƒ£ ConexÃ£o com Banco de Dados (SQLAlchemy)
ğŸ“Œ Arquivo
backend/api/db/session.py

ğŸ“Œ O que foi feito

Criamos a engine do SQLAlchemy usando settings.DATABASE_URL

Configuramos:

pool_pre_ping=True

SessionLocal

engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
)

ğŸ§ª Teste realizado

Dentro do container:

from backend.api.db.session import engine

with engine.connect() as conn:
    print("ğŸ”¥ Conectado com sucesso ao Postgres!")

âœ… Resultado

ConexÃ£o funcionando

Banco acessÃ­vel

Infraestrutura validada ponta a ponta

7ï¸âƒ£ OrganizaÃ§Ã£o e Boas PrÃ¡ticas Gerais

âœ” SeparaÃ§Ã£o clara de responsabilidades
âœ” CÃ³digo preparado para crescer
âœ” Arquitetura limpa
âœ” Sem gambiarras
âœ” Pronto para:

autenticaÃ§Ã£o

migraÃ§Ãµes

seguranÃ§a

deploy futuro

ğŸ§  ConclusÃ£o TÃ©cnica

Neste estÃ¡gio, o RobotSystem possui:

âœ… Ambiente totalmente containerizado
âœ… Banco persistente e confiÃ¡vel
âœ… Backend operacional
âœ… ConfiguraÃ§Ã£o profissional
âœ… Base sÃ³lida para autenticaÃ§Ã£o e regras de negÃ³cio

8ï¸âƒ£ FastAPI como Framework da API
ğŸ“Œ O que foi feito

O backend do RobotSystem foi construÃ­do usando FastAPI

A aplicaÃ§Ã£o Ã© inicializada a partir de:

backend/api/main.py


O servidor Ã© executado com:

uvicorn backend.api.main:app


A API roda:

Dentro de um container Docker

Exposta na porta 8000

Com suporte a hot reload em ambiente de desenvolvimento

ğŸ¯ Por que FastAPI?

Alto desempenho (baseado em Starlette + Pydantic)

ValidaÃ§Ã£o automÃ¡tica de dados

GeraÃ§Ã£o automÃ¡tica de documentaÃ§Ã£o (Swagger / OpenAPI)

Excelente integraÃ§Ã£o com SQLAlchemy

PadrÃ£o moderno para APIs REST profissionais

âœ… Resultado

API operacional dentro do container

Pronta para receber:

rotas

dependÃªncias

autenticaÃ§Ã£o

middlewares

versionamento

9ï¸âƒ£ Ambiente de Desenvolvimento com WSL (Ubuntu)
ğŸ“Œ O que foi feito

Todo o projeto estÃ¡ sendo desenvolvido usando:

WSL (Windows Subsystem for Linux)

DistribuiÃ§Ã£o: Ubuntu

Docker e Docker Compose estÃ£o rodando dentro do ambiente Linux, nÃ£o diretamente no Windows

ğŸ¯ Impacto tÃ©cnico

Ambiente muito mais prÃ³ximo de produÃ§Ã£o

Menos problemas de compatibilidade

Melhor performance com Docker

PadronizaÃ§Ã£o do ambiente de desenvolvimento

ğŸ“‚ Estrutura de trabalho
/mnt/c/Users/Alex/Documents/robotsystem/src


CÃ³digo armazenado no Windows

Executado no contexto Linux via WSL

Containers acessando o projeto corretamente via bind / copy

ğŸ”— IntegraÃ§Ã£o Geral (Resumo Atualizado)

âœ” FastAPI rodando com Uvicorn
âœ” Docker + Docker Compose no WSL Ubuntu
âœ” PostgreSQL com volume persistente
âœ” SQLAlchemy conectado com sucesso
âœ” ConfiguraÃ§Ã£o centralizada (Settings)
âœ” Imports absolutos (backend.api.*)
âœ” Ambiente preparado para produÃ§Ã£o

ğŸ§  ConclusÃ£o Final (Atualizada)

O RobotSystem atualmente possui:

ğŸ”¥ Uma API FastAPI moderna
ğŸ§ Rodando em Linux (WSL Ubuntu)
ğŸ³ Totalmente containerizada
ğŸ—„ï¸ Com banco persistente
ğŸ§© Arquitetura limpa e escalÃ¡vel